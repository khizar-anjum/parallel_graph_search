void BellmanFord(std::vector<std::pair<int, std::pair<int,int>> > graph, int source, std::unordered_map<int,int> &parent_map)
{
	using namespace std;
	vector<int> distance(nodes, INT_MAX);
	distance[source]=0;
// Relax all edges nodes-1 times to get the shortest possible distance
	for(int i=0;i<nodes;i++)
	{
		for(int j=0;j<edges;j++)
		{
			int source=graph[j].second.first;
			int destination=graph[j].second.second;
			int weight=graph[j].first;
			if(distance[source]!=INT_MAX&&distance[source]+weight<distance[destination])
			{
				distance[destination]=distance[source]+weight;
				parent_map[destination]=source;
			}
		}
	}
/* If after relaxing all edges for nodes-1 time we still get a shorter path that indicates
 a negative weight cycle */
	for(int j=0;j<edges;j++)
		{
			int source=graph[j].second.first;
			int destination=graph[j].second.second;
			int weight=graph[j].first;
			if(distance[source]!=INT_MAX&&distance[source]+weight<distance[destination])
			{
				cout<<"Graph contains negative weight cycle\n";
				exit(0);
			}
		}
	print_distance(distance);
}

Reference: https://iq.opengenus.org/bellman-ford-algorithm/#algorithm
